<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>TOTP令牌管理器</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
    <style>
    body { background: #f7f8fa; }
    .search-box-sticky {
  position: sticky;
  top: 0;
  z-index: 101;
  width: 100%;
  margin-bottom: 1.5rem !important;
  background: #fff;
  border-radius: 1.5rem;
  box-shadow: 0 4px 16px #0002;
  padding: 0.7rem 1.2rem;
  display: flex;
  align-items: center;
  border: 1px solid #e3e6ea;
}
@media (max-width: 600px) {
  .search-box-sticky {
    flex-wrap: nowrap;
    padding: 0.3rem 0.3rem;
    gap: 0.2rem;
    border-radius: 0.8rem;
    min-height: unset;
    box-shadow: 0 2px 8px #0001;
  }
  .search-box-sticky input[type="text"] {
    font-size: 1rem;
    height: 2.1rem;
    padding: 0.2rem 0.6rem;
  }
  .search-box-sticky .btn, .search-box-sticky input[type="checkbox"] {
    height: 2.1rem;
    width: 2.1rem;
    min-width: 2.1rem;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .search-box-sticky .dropdown-menu {
    min-width: 8rem;
    font-size: 1rem;
  }
}
    .token-card { margin-bottom: 1rem; }
    .token-info-row, .token-code-row { display: flex; align-items: center; justify-content: space-between; }
    .token-code { font-size: 1.5rem; font-family: monospace; cursor: pointer; user-select: all; }
    .totp-pie { vertical-align: middle; margin-left: 8px; }
    #toastArea { position: fixed; top: 1.2rem; right: 1.2rem; z-index: 2000; min-width: 220px; max-width: 90vw; }
    .toast .toast-body { word-break: break-all; white-space: pre-line; }
    .toast { box-shadow: 0 2px 12px rgba(0,0,0,0.08); border-radius: 8px; }
    @media (max-width: 600px) {
      #toastArea { top: 0.5rem; right: 0.5rem; left: 0.5rem; }
    }
    /* 移动端卡片滑动手势样式 */
    @media (max-width: 600px) {
  .token-card { position: relative; overflow: visible; }
    }
    /* ========== 动画与自适应主题 ========== */
    .token-card {
      transition: box-shadow 0.2s, transform 0.2s, background 0.2s;
    }
    .token-card:active {
      box-shadow: 0 2px 16px #0002;
      background: #f0f4ff;
    }
    .modal-content {
      transition: transform 0.2s, opacity 0.2s;
      transform: scale(0.98);
      opacity: 0.7;
    }
    .modal.show .modal-content {
      transform: scale(1);
      opacity: 1;
    }
    .toast {
      transition: opacity 0.3s, transform 0.3s;
      opacity: 0;
      transform: translateY(-10px);
    }
    .toast.show, .toast.fade.show {
      opacity: 1;
      transform: translateY(0);
    }
    @media (prefers-color-scheme: dark) {
      body { background: #181a1b; color: #e3e6ea; }
      .card, .modal-content { background: #23272b; color: #e3e6ea; }
      .search-box-sticky { background: #23272b; border-color: #333; }
      .form-control, .form-check-input { background: #23272b; color: #e3e6ea; border-color: #444; }
      .toast { background: #23272b; color: #e3e6ea; }
      .btn-close, .btn-close-white { filter: invert(1); }
      .dropdown-menu { background: #23272b; color: #e3e6ea; }
      .progress-bar { background: #0d6efd; }
      .form-control {
        color: #e3e6ea !important;
        background: #23272b;
        border-color: #444;
      }
      .form-control::placeholder {
        color: #b0b3b8 !important;
        opacity: 1;
      }
      .bi-github {
        color: #e3e6ea !important;
        filter: none !important;
      }
      .btn-outline-dark .bi,
      .btn-outline-secondary .bi {
        color: #e3e6ea !important;
      }
      .dropdown-menu {
        background: #23272b;
        color: #e3e6ea;
      }
      .dropdown-menu .dropdown-item {
        color: #e3e6ea !important;
      }
      .dropdown-menu .dropdown-item .bi {
        color: #e3e6ea !important;
      }
      .dropdown-menu .dropdown-item:active,
      .dropdown-menu .dropdown-item:focus,
      .dropdown-menu .dropdown-item:hover {
        background: #343a40 !important;
        color: #fff !important;
      }
    }
    </style>
</head>
<body>
<div id="app"></div>
<div id="toastArea"></div>

<!-- Vue 3 -->
<script src="https://cdn.jsdelivr.net/npm/vue@3.4.21/dist/vue.global.prod.js"></script>
<!-- Bootstrap 5 CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<!-- Bootstrap 5 JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<!-- CryptoJS (HMAC-SHA1 for TOTP) -->
<script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>

    <script>
function showToast(msg, type = 'info', delay = 2200) {
  const toastArea = document.getElementById('toastArea');
  const id = 'toast-' + Date.now() + Math.random().toString(36).slice(2, 8);
  const icon = type === 'success' ? 'bi-check-circle-fill' : type === 'danger' ? 'bi-x-circle-fill' : 'bi-info-circle-fill';
  const bg = type === 'success' ? 'bg-success' : type === 'danger' ? 'bg-danger' : 'bg-info';
  const html = `
    <div id="${id}" class="toast align-items-center text-white ${bg} border-0 mb-2" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="${delay}">
      <div class="d-flex">
        <div class="toast-body"><i class="bi ${icon} me-2"></i>${msg}</div>
        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="关闭"></button>
      </div>
    </div>`;
  toastArea.insertAdjacentHTML('beforeend', html);
  const toastEl = document.getElementById(id);
  const toast = new bootstrap.Toast(toastEl);
  toast.show();
  toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
}
window.showToast = showToast;

function showUndoToast(msg, onUndo, delay = 4000) {
  const toastArea = document.getElementById('toastArea');
  const id = 'toast-' + Date.now() + Math.random().toString(36).slice(2, 8);
  const html = `
    <div id="${id}" class="toast align-items-center text-white bg-danger border-0 mb-2 shadow" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="${delay}" style="min-width:260px;">
      <div class="d-flex align-items-center px-2 py-1">
        <i class="bi bi-x-circle-fill me-2 fs-5"></i>
        <div class="toast-body flex-grow-1 py-0" style="font-size:1.05rem;">${msg}</div>
        <button type="button" class="btn btn-sm btn-undo-toast ms-2 me-1" id="undoBtn${id}">撤销</button>
        <button type="button" class="btn-close btn-close-white ms-1" data-bs-dismiss="toast" aria-label="关闭"></button>
      </div>
    </div>
    <style>
      .btn-undo-toast {
        background: rgba(255,255,255,0.95);
        color: #d32f2f;
        border: none;
        border-radius: 1.2em;
        font-weight: 500;
        padding: 0.2em 1.1em;
        font-size: 1rem;
        transition: background 0.2s, color 0.2s;
      }
      .btn-undo-toast:hover {
        background: #fff;
        color: #b71c1c;
      }
    </style>
  `;
  toastArea.insertAdjacentHTML('beforeend', html);
  const toastEl = document.getElementById(id);
  const toast = new bootstrap.Toast(toastEl);
  toast.show();
  toastEl.querySelector(`#undoBtn${id}`).onclick = () => {
    toast.hide();
    if (onUndo) onUndo();
  };
  toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
}

const uuidv4 = () => (window.crypto && window.crypto.randomUUID ? window.crypto.randomUUID() : Math.random().toString(36).slice(2, 10) + Date.now());
const { createApp, ref, reactive, computed, onMounted, watch, nextTick, provide } = Vue;

// TOTP算法实现（兼容原生JS版）
    function base32ToBytes(base32) {
      const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
      let clean = base32.replace(/\s+/g, '').toUpperCase();
  while (clean.endsWith('=')) clean = clean.slice(0, -1);
  let buffer = 0, bitsLeft = 0, bytes = [];
      for (let i = 0; i < clean.length; i++) {
        const val = alphabet.indexOf(clean[i]);
    if (val === -1) return null;
        buffer = (buffer << 5) | val;
        bitsLeft += 5;
        while (bitsLeft >= 8) {
          bitsLeft -= 8;
      bytes.push((buffer >>> bitsLeft) & 0xff);
    }
  }
  if (bitsLeft > 0) bytes.push((buffer << (8 - bitsLeft)) & 0xff);
      return new Uint8Array(bytes);
    }
    function leftPad(str, len, pad) {
      str = String(str);
      while (str.length < len) str = pad + str;
      return str;
    }
function hotp(secretBytes, counter) {
  // 兼容uuidv4和window.Crypto
  const key = secretBytes;
  const counterBytes = new Uint8Array(8);
  let tmp = counter;
  for (let i = 7; i >= 0; --i) {
    counterBytes[i] = tmp & 0xff;
    tmp = tmp >> 8;
  }
  // HMAC-SHA1
  const crypto = window.crypto || window.msCrypto;
  if (!crypto || !crypto.subtle) return '无效密钥';
  // 这里用同步polyfill（兼容性更好）
  // 直接用jsSHA1实现
  // 由于CDN限制，这里用window.CryptoJS（如有）
  if (window.CryptoJS) {
    const u8ToWordArray = (u8arr) => {
      var words = [], i = 0, len = u8arr.length;
      for (; i < len; i += 4) {
        var word = 0;
        if (i < len) word |= (u8arr[i] & 0xff) << 24;
        if (i + 1 < len) word |= (u8arr[i + 1] & 0xff) << 16;
        if (i + 2 < len) word |= (u8arr[i + 2] & 0xff) << 8;
        if (i + 3 < len) word |= (u8arr[i + 3] & 0xff);
        words.push(word);
      }
      return window.CryptoJS.lib.WordArray.create(words, len);
    };
    const keyWord = u8ToWordArray(key);
      const counterWord = u8ToWordArray(counterBytes);
    const hmac = window.CryptoJS.HmacSHA1(counterWord, keyWord);
    const hmacHex = hmac.toString(window.CryptoJS.enc.Hex);
      const hmacBytes = [];
    for (let i = 0; i < hmacHex.length; i += 2) hmacBytes.push(parseInt(hmacHex.substr(i, 2), 16));
    const offset = hmacBytes[hmacBytes.length - 1] & 0xf;
    const binCode = ((hmacBytes[offset] & 0x7f) << 24) |
      ((hmacBytes[offset + 1] & 0xff) << 16) |
      ((hmacBytes[offset + 2] & 0xff) << 8) |
      (hmacBytes[offset + 3] & 0xff);
      return leftPad(binCode % 1000000, 6, '0');
  }
  return '无效密钥';
    }
    function totp(secret, remainTick) {
      const bytes = base32ToBytes(secret);
      if (!bytes) return '无效密钥';
      const period = 30;
      const counter = Math.floor(Date.now() / 1000 / period);
      return hotp(bytes, counter);
    }

createApp({
  setup() {
    let undoTimer = null;
    // 全局状态
    const tokens = ref([]); // 令牌列表
    const selectedIds = ref([]); // 批量选择（数组）
    const recentlyDeleted = ref(null); // 撤销删除
    const toastList = ref([]); // Toast队列
    const search = ref('');
    const remain = ref(30 - (Math.floor(Date.now() / 1000) % 30));
    const isMobile = ref(window.innerWidth <= 600);
    const isMultiSelectMode = ref(false);
    let longPressTimer = null;

    // 定时刷新动态码与倒计时
    setInterval(() => {
      remain.value = 30 - (Math.floor(Date.now() / 1000) % 30);
    }, 1000);
    window.addEventListener('resize', () => {
      isMobile.value = window.innerWidth <= 600;
    });

    // 启动时加载本地存储
    onMounted(() => {
      try {
        const arr = JSON.parse(localStorage.getItem('totp_tokens') || '[]');
        if (Array.isArray(arr)) tokens.value = arr;
      } catch {}
    });
    // tokens变更自动保存
    watch(tokens, (val) => {
      localStorage.setItem('totp_tokens', JSON.stringify(val));
    }, { deep: true });

    // 令牌过滤
    const filteredTokens = computed(() => {
      if (!search.value.trim()) return tokens.value;
      const kw = search.value.trim().toLowerCase();
      return tokens.value.filter(t =>
          (t.userInfo && t.userInfo.toLowerCase().includes(kw)) ||
          (t.secret && t.secret.toLowerCase().includes(kw))
        );
    });

    // 全选checkbox联动
    const allSelected = computed({
      get() {
        return filteredTokens.value.length > 0 &&
          filteredTokens.value.every(t => selectedIds.value.includes(t.id));
      },
      set(val) {
        if (val) {
          // 只添加当前可见的
          selectedIds.value = filteredTokens.value.map(t => t.id);
        } else {
          // 只移除当前可见的
          selectedIds.value = selectedIds.value.filter(id => !filteredTokens.value.some(t => t.id === id));
        }
      }
    });

    // 令牌操作
    function selectAll() {
      selectedIds.value.splice(0, selectedIds.value.length, ...filteredTokens.value.map(t => t.id));
    }
    function clearSelect() {
      selectedIds.value.splice(0, selectedIds.value.length);
    }
    function deleteToken(id) {
  const idx = tokens.value.findIndex(t => t.id === id);
  if (idx === -1) return;
  const token = tokens.value[idx];
  tokens.value.splice(idx, 1);
  selectedIds.value.splice(selectedIds.value.indexOf(id), 1);
  recentlyDeleted.value = { token, idx };
  // 撤销Toast
  showUndoToast('令牌已删除', () => {
    // 撤销操作
    tokens.value.splice(recentlyDeleted.value.idx, 0, recentlyDeleted.value.token);
    recentlyDeleted.value = null;
    if (undoTimer) { clearTimeout(undoTimer); undoTimer = null; }
    // 重新保存
    localStorage.setItem('totp_tokens', JSON.stringify(tokens.value));
  });
  // 超时后才真正保存
  if (undoTimer) clearTimeout(undoTimer);
  undoTimer = setTimeout(() => {
    if (recentlyDeleted.value) {
      localStorage.setItem('totp_tokens', JSON.stringify(tokens.value));
      recentlyDeleted.value = null;
    }
  }, 4000);
}
function copyCode(code, event) {
  navigator.clipboard.writeText(code).then(() => {
    if (isMobile.value) {
      showToast('已复制动态码', 'success');
    } else {
      if (event && event.clientX && event.clientY) {
        const tip = document.createElement('div');
        tip.textContent = '已复制';
        tip.style.position = 'fixed';
        tip.style.top = (event.clientY - 30) + 'px';
        tip.style.left = (event.clientX - 20) + 'px';
        tip.style.background = '#222';
        tip.style.color = '#fff';
        tip.style.padding = '2px 10px';
        tip.style.borderRadius = '8px';
        tip.style.fontSize = '0.95rem';
        tip.style.zIndex = 9999;
        document.body.appendChild(tip);
        setTimeout(() => tip.remove(), 900);
      } else {
        showToast('已复制动态码', 'success');
      }
    }
  }).catch(err => {
    showToast('复制失败，请手动复制', 'danger');
    console.error('复制失败:', err);
  });
}

    // 进度条百分比
    const progressPercent = computed(() => 100 - remain.value * 100 / 30);

    // ========== 新增/编辑弹窗逻辑 ==========
    const showAddModal = ref(false);
    const showEditModal = ref(false);
    const addForm = reactive({ userInfo: '', secret: '', error: '' });
    const editForm = reactive({ userInfo: '', secret: '', error: '' });
    const editingToken = ref(null);

    function openAddModal() {
      addForm.userInfo = '';
      addForm.secret = '';
      addForm.error = '';
      showAddModal.value = true;
    }
    function addToken() {
      const userInfo = addForm.userInfo;
      const secret = addForm.secret;
      if (!secret || !base32ToBytes(secret)) {
        showToast('密钥不能为空且必须为有效 Base32 格式', 'danger');
        return false;
      }
      if (tokens.value.some(t => t.userInfo === userInfo && t.secret === secret)) {
        showToast('该令牌已存在，请勿重复添加', 'danger');
        return false;
      }
      tokens.value.push({ id: uuidv4(), userInfo, secret, created: Date.now() });
      showToast('添加成功', 'success');
      showAddModal.value = false; // 关闭新增弹窗
      return true;
    }
    function openEditModal(token) {
      editingToken.value = token;
      editForm.userInfo = token.userInfo;
      editForm.secret = token.secret;
      editForm.error = '';
      showEditModal.value = true;
      nextTick(() => {
        // 聚焦第一个输入框
        const input = document.querySelector('.modal.show input');
        if (input) input.focus();
      });
    }
    function closeEditModal() {
      showEditModal.value = false;
      editingToken.value = null;
      editForm.userInfo = '';
      editForm.secret = '';
      editForm.error = '';
    }
    function saveEdit() {
      if (!editForm.secret || !base32ToBytes(editForm.secret)) {
        editForm.error = '密钥不能为空且必须为有效 Base32 格式';
        return;
      }
      // 检查是否与其它令牌重复（排除自己）
      if (tokens.value.some(t => t !== editingToken.value && t.userInfo === editForm.userInfo && t.secret === editForm.secret)) {
        editForm.error = '该令牌已存在，请勿重复';
        return;
      }
      editingToken.value.userInfo = editForm.userInfo;
      editingToken.value.secret = editForm.secret;
      closeEditModal();
    }

    // ========== 二维码导出弹窗 ==========
    const showQRModal = ref(false);
    const qrToken = ref(null);
    async function openQRModal(token) {
      qrToken.value = token;
      showQRModal.value = true;
      nextTick(async () => {
        // 生成 otpauth URI
        const uri = `otpauth://totp/${encodeURIComponent(token.userInfo || 'TOTP')}?secret=${token.secret}&issuer=TOTPManager`;
        const qrDiv = document.getElementById('qrcode');
        if (qrDiv) {
          qrDiv.innerHTML = '';
          try {
            await loadKjua(); // 确保 kjua 已加载
            const isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const qr = kjua({
              text: uri || 'empty',
              size: 220,
              render: 'svg',
              quiet: 2,
              background: isDark ? '#23272b' : '#fff',
              fill: isDark ? '#fff' : '#111'
            });
            qrDiv.appendChild(qr);
          } catch (e) {
            qrDiv.innerHTML = '<div class="text-danger">二维码生成失败</div>';
          }
        }
      });
    }

    // ========== 移动端动态码小圆饼倒计时 ==========
    function drawTotpPie(canvas, percent) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, 28, 28);
      // 背景灰色圆环
      ctx.beginPath();
      ctx.arc(14, 14, 12, 0, 2 * Math.PI);
      ctx.strokeStyle = '#eee';
      ctx.lineWidth = 4;
      ctx.stroke();
      // 剩余部分蓝色
      ctx.beginPath();
      ctx.arc(14, 14, 12, -Math.PI/2, -Math.PI/2 + 2 * Math.PI * percent, false);
      ctx.strokeStyle = '#0d6efd';
      ctx.lineWidth = 4;
      ctx.stroke();
    }
    function refreshTotpPies() {
      if (!isMobile.value) return;
      filteredTokens.value.forEach(token => {
        const canvas = document.getElementById('pie-' + token.id);
        if (!canvas) return;
        const period = 30;
        const now = Math.floor(Date.now() / 1000);
        const remain = period - (now % period);
        drawTotpPie(canvas, remain / period);
      });
    }
    onMounted(() => {
      setInterval(refreshTotpPies, 1000);
      nextTick(refreshTotpPies);
    });

    // ========== 批量导入多格式支持 ==========
    async function handleFiles(files) {
      showToast('正在处理文件，共' + files.length + '个', 'info', 1200);
      if (!files || !files.length) {
        showToast('未检测到文件', 'danger');
        return;
      }
      scanProgress.value = { total: files.length, success: 0, fail: 0, running: true };
      let success = 0, fail = 0;
      for (const file of files) {
        const ext = file.name.split('.').pop().toLowerCase();
        if (file.type.startsWith('image/')) {
          if (await processImageFile(file)) {
            success++;
          } else {
            fail++;
          }
        } else {
          try {
            const text = await readFileAsText(file);
            let ok = false;
            if (ext === 'json') {
              ok = importFromJSON(text);
            } else if (ext === 'csv') {
              ok = importFromCSV(text);
            } else if (ext === 'txt') {
              ok = importFromTxt(text);
              if (!ok) {
                // 尝试作为加密文件处理
                ok = importFromEncrypted(text);
              }
            }
            if (ok) success++; else fail++;
          } catch (e) {
            fail++;
            showToast(`文件 "${file.name}" 处理异常: ${e.message}`, 'danger');
          }
        }
        scanProgress.value = { ...scanProgress.value, success, fail };
      }
      scanProgress.value.running = false;
      showToast('文件导入完成，成功:' + success + '，失败:' + fail, fail ? 'danger' : 'success');
      if (success > 0) showScanModal.value = false;
    }
    function importFromJSON(text) {
      try {
        const arr = JSON.parse(text);
        if (!Array.isArray(arr)) {
          showToast('JSON 文件格式错误：根元素必须是数组', 'danger');
          return false;
        }
        let count = 0;
        let skipped = 0;
        let invalid = 0;
        arr.forEach(item => {
          if (item.secret && base32ToBytes(item.secret)) {
            let userInfo = item.userInfo || item.account || '';
            if (!tokens.value.some(t => t.userInfo === userInfo && t.secret === item.secret)) {
              tokens.value.push({ id: uuidv4(), userInfo, secret: item.secret, created: Date.now() });
              count++;
            } else {
              skipped++;
            }
          } else {
            invalid++;
          }
        });
        if (invalid > 0) {
          showToast(`JSON导入：${invalid}个条目包含无效的密钥格式`, 'warning');
        }
        if (skipped > 0) {
          showToast(`JSON导入完成：新增${count}个，跳过${skipped}个已存在的令牌`, count > 0 ? 'success' : 'info');
        }
        return count > 0;
      } catch (e) {
        showToast('JSON 文件格式错误：' + e.message, 'danger');
        return false;
      }
    }
    function importFromTxt(text) {
      // 支持otpauth://URI批量导入
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      let count = 0;
      let skipped = 0;
      lines.forEach(line => {
        if (line.startsWith('otpauth://totp/')) {
          if (handleQrData(line)) {
            count++;
          } else {
            // handleQrData 已经显示了跳过提示，这里只统计
            skipped++;
          }
        }
      });
      if (skipped > 0 && count === 0) {
        showToast(`TXT导入完成：跳过${skipped}个已存在的令牌`, 'info');
      }
      return count > 0;
    }
    function importFromCSV(text) {
      // 简单CSV: userInfo,secret
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      let count = 0;
      let skipped = 0;
      let invalid = 0;
      lines.forEach(line => {
        const parts = line.split(',');
        if (parts.length >= 2) {
          const userInfo = parts[0];
          const secret = parts[1];
          if (secret && base32ToBytes(secret)) {
            if (!tokens.value.some(t => t.userInfo === userInfo && t.secret === secret)) {
              tokens.value.push({ id: uuidv4(), userInfo, secret, created: Date.now() });
              count++;
            } else {
              skipped++;
            }
          } else {
            invalid++;
          }
        }
      });
      if (invalid > 0) {
        showToast(`CSV导入：${invalid}行包含无效的密钥格式`, 'warning');
      }
      if (skipped > 0) {
        showToast(`CSV导入完成：新增${count}个，跳过${skipped}个已存在的令牌`, count > 0 ? 'success' : 'info');
      }
      return count > 0;
    }
    function importFromEncrypted(text) {
      const password = prompt('请输入加密密码：');
      if (!password) { showToast('已取消导入', 'info'); return false; }
      try {
        const decrypted = decryptData(text, password);
        if (!decrypted) {
          showToast('密码错误或文件损坏，请检查密码是否正确', 'danger');
          return false;
        }
        
        // 尝试解析为JSON
        let parsedData;
        try {
          parsedData = JSON.parse(decrypted);
        } catch (jsonError) {
          showToast('解密成功，但文件内容不是有效的JSON格式', 'warning');
          return false;
        }
        
        // 检查是否为数组
        if (!Array.isArray(parsedData)) {
          showToast('解密成功，但文件内容不是有效的令牌数组格式', 'warning');
          return false;
        }
        
        // 验证数组内容
        let count = 0;
        let skipped = 0;
        let invalid = 0;
        parsedData.forEach(item => {
          if (item.secret && base32ToBytes(item.secret)) {
            let userInfo = item.userInfo || item.account || '';
            if (!tokens.value.some(t => t.userInfo === userInfo && t.secret === item.secret)) {
              tokens.value.push({ id: uuidv4(), userInfo, secret: item.secret, created: Date.now() });
              count++;
            } else {
              skipped++;
            }
          } else {
            invalid++;
          }
        });
        
        if (invalid > 0) {
          showToast(`加密文件导入：${invalid}个条目包含无效的密钥格式`, 'warning');
        }
        if (skipped > 0) {
          showToast(`加密文件导入完成：新增${count}个，跳过${skipped}个已存在的令牌`, count > 0 ? 'success' : 'info');
        } else if (count > 0) {
          showToast(`加密文件导入成功：新增${count}个令牌`, 'success');
        } else {
          showToast('加密文件导入完成：没有新增令牌', 'info');
        }
        
        return count > 0;
      } catch (e) {
        showToast('解密失败: ' + e.message, 'danger');
        return false;
      }
    }
    async function processImageFile(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = async evt => {
          const img = new window.Image();
          img.onload = async () => {
            await loadJsQR(); // 确保 jsQR 已加载
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const code = jsQR(imageData.data, imageData.width, imageData.height);
            if (code && code.data && handleQrData(code.data)) resolve(true);
            else {
              showToast(`图片 "${file.name}" 中未检测到有效的二维码`, 'info');
              resolve(false);
            }
          };
          img.onerror = () => {
            showToast(`图片 "${file.name}" 加载失败，请检查文件格式`, 'danger');
            resolve(false);
          };
          img.src = evt.target.result;
        };
        reader.onerror = () => {
          showToast(`文件 "${file.name}" 读取失败`, 'danger');
          resolve(false);
        };
        reader.readAsDataURL(file);
      });
    }
    function handleQrData(data) {
      if (data.startsWith('otpauth://totp/')) {
        try {
          const url = new URL(data);
          const secret = url.searchParams.get('secret');
          const userInfo = decodeURIComponent(url.pathname.slice(1));
          if (secret && base32ToBytes(secret)) {
            if (!tokens.value.some(t => t.userInfo === userInfo && t.secret === secret)) {
              tokens.value.push({ id: uuidv4(), userInfo, secret, created: Date.now() });
              return true;
            } else {
              // 令牌已存在，给用户提示
              showToast(`令牌 "${userInfo}" 已存在，跳过导入`, 'info');
              return false;
            }
          } else {
            showToast(`无效的 TOTP 密钥格式: ${userInfo || '未知'}`, 'danger');
            return false;
          }
        } catch (e) {
          showToast(`无效的 otpauth URI 格式`, 'danger');
          return false;
        }
      }
      return false;
    }

    // ========== 摄像头扫码功能 ==========
    const cameraActive = ref(false);
    let videoStream = null;
    function startCamera() {
      const video = document.getElementById('qrVideo');
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast('此浏览器不支持摄像头调用', 'danger');
        return;
      }
      navigator.mediaDevices.getUserMedia({video: {facingMode: 'environment'}}).then(stream => {
        videoStream = stream;
        video.srcObject = stream;
        video.setAttribute('playsinline', true);
        video.play();
        cameraActive.value = true;
        scanLoop();
      }).catch(err => {
        showToast('无法访问摄像头: ' + err.name, 'danger');
      });
    }
    function stopCamera() {
      if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
      }
      cameraActive.value = false;
      const video = document.getElementById('qrVideo');
      if (video) video.srcObject = null;
    }
    async function scanLoop() {
      const video = document.getElementById('qrVideo');
      if (!videoStream || !cameraActive.value) return;
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        await loadJsQR(); // 确保 jsQR 已加载
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const code = jsQR(imageData.data, imageData.width, imageData.height);
        if (code && code.data) {
          if (handleQrData(code.data)) {
            showToast('扫码导入成功！', 'success');
            // 询问用户是否继续扫描
            if (confirm('✅ 扫码成功！\n\n是否继续扫描其他二维码？\n\n• 点击"确定"继续扫描\n• 点击"取消"停止扫描')) {
              // 继续扫描，延迟一下避免重复扫描同一个码
              setTimeout(scanLoop, 2000);
            } else {
              stopCamera();
              showToast('已停止扫码', 'info');
              showScanModal.value = false; // 关闭批量扫码导入弹窗
            }
            return;
          }
        }
      }
      setTimeout(scanLoop, 500);
    }

    // ========== Gist 备份/恢复 ==========
    const showGistModal = ref(false);
    const gistPAT = ref(localStorage.getItem('gist_pat') || '');
    const gistError = ref('');
    function openGistModal() {
      gistPAT.value = localStorage.getItem('gist_pat') || '';
      gistError.value = '';
      showGistModal.value = true;
    }
    function saveGistPAT() {
      if (!gistPAT.value) {
        gistError.value = 'PAT不能为空';
        return;
      }
      localStorage.setItem('gist_pat', gistPAT.value);
      showGistModal.value = false;
      showToast('PAT已保存', 'success');
    }
    // 获取加密/解密密码的通用函数
    async function getEncryptPassword(defaultPwd) {
      return new Promise((resolve) => {
        const useCustom = confirm('是否自定义加密密码？\n点击"确定"自定义，点击"取消"使用默认密码（如PAT）');
        if (useCustom) {
          const pwd = prompt('请输入自定义加密密码：');
          if (!pwd) {
            showToast('已取消操作', 'info');
            return resolve(null);
          }
          resolve(pwd);
        } else {
          if (!defaultPwd) {
            showToast('默认密码不能为空', 'danger');
            return resolve(null);
          }
          resolve(defaultPwd);
        }
      });
    }
    // Gist加密备份
    async function backupToGist() {
      if (!gistPAT.value) { showToast('请先配置PAT', 'danger'); return; }
      try {
        const data = JSON.stringify(tokens.value, null, 2);
        const password = await getEncryptPassword(gistPAT.value);
        if (!password) { showToast('已取消备份', 'info'); return; }
        const encrypted = encryptData(data, password);
        // 查找是否已有 totp_tokens_encrypted.txt 的 gist，只用第一个
        const res = await fetch('https://api.github.com/gists', {
          headers: { Authorization: 'token ' + gistPAT.value }
        });
        if (!res.ok) throw new Error('获取 Gist 列表失败');
        const gists = await res.json();
        let gist = gists.find(g => g.files && g.files['totp_tokens_encrypted.txt']);
        let gistId;
        if (gist) {
          gistId = gist.id;
        } else {
          // 没有则新建
          const createRes = await fetch('https://api.github.com/gists', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', Authorization: 'token ' + gistPAT.value },
            body: JSON.stringify({
              description: 'TOTP 令牌加密自动备份',
              public: false,
              files: { 'totp_tokens_encrypted.txt': { content: encrypted } }
            })
          });
          if (!createRes.ok) throw new Error('创建 Gist 失败');
          const data = await createRes.json();
          gistId = data.id;
        }
        // 更新 gist，只更新 totp_tokens_encrypted.txt 文件内容
        const patchRes = await fetch('https://api.github.com/gists/' + gistId, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json', Authorization: 'token ' + gistPAT.value },
          body: JSON.stringify({
            files: { 'totp_tokens_encrypted.txt': { content: encrypted } }
          })
        });
        if (!patchRes.ok) throw new Error('Gist 更新失败');
        showToast('Gist 加密备份成功！', 'success');
        showExportModal.value = false;
        showGistModal.value = false;
      } catch (e) {
        showToast('Gist 备份失败：' + e.message, 'danger');
      }
    }
    // Gist加密恢复
    async function restoreFromGist() {
      if (!gistPAT.value) { showToast('请先配置PAT', 'danger'); return; }
      try {
        // 查找 gist
        const res = await fetch('https://api.github.com/gists', {
          headers: { Authorization: 'token ' + gistPAT.value }
        });
        if (!res.ok) throw new Error('获取 Gist 列表失败');
        const gists = await res.json();
        const gist = gists.find(g => g.files && g.files['totp_tokens_encrypted.txt']);
        if (!gist) throw new Error('未找到 totp_tokens_encrypted.txt Gist');
        const rawUrl = gist.files['totp_tokens_encrypted.txt'].raw_url;
        const fileRes = await fetch(rawUrl);
        if (!fileRes.ok) throw new Error('下载 Gist 文件失败');
        const encrypted = await fileRes.text();
        const password = await getEncryptPassword(gistPAT.value);
        if (!password) { showToast('已取消恢复', 'info'); return; }
        const decrypted = decryptData(encrypted, password);
        if (!decrypted) throw new Error('密码错误或文件损坏');
        const arr = JSON.parse(decrypted);
        if (!Array.isArray(arr)) throw new Error('Gist 文件内容格式错误');
        tokens.value = arr;
        showToast('Gist 恢复成功！', 'success');
        showExportModal.value = false;
        showGistModal.value = false;
      } catch (e) {
        showToast('Gist 恢复失败：' + e.message, 'danger');
      }
    }

    // ========== 批量操作 ==========
    function batchDelete() {
      if (!selectedIds.value.length) { showToast('请先选择要删除的令牌', 'info'); return; }
      if (!confirm(`确定要删除选中的${selectedIds.value.length}个令牌吗？`)) return;
      const before = tokens.value.length;
      tokens.value = tokens.value.filter(t => !selectedIds.value.includes(t.id));
      selectedIds.value = [];
      showToast(`已删除${before - tokens.value.length}个令牌`, 'success');
    }
    function batchExportJSON() {
      if (!selectedIds.value.length) { showToast('请先选择要导出的令牌', 'info'); return; }
      const arr = tokens.value.filter(t => selectedIds.value.includes(t.id));
      const data = JSON.stringify(arr, null, 2);
      const blob = new Blob([data], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'totp_tokens_selected.json';
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      showToast('已导出JSON', 'success');
    }

    // 批量扫码导入弹窗和进度
    const showScanModal = ref(false);
    const scanProgress = reactive({ total: 0, success: 0, fail: 0, running: false });
    function openScanModal() {
      showScanModal.value = true;
      scanProgress.total = 0;
      scanProgress.success = 0;
      scanProgress.fail = 0;
      scanProgress.running = false;
    }

    // 修复：watch(showScanModal, ...) 必须在 setup 内部
    watch(showScanModal, v => { if (!v) stopCamera(); });

    // 提供showToast到组件内
    provide('showToast', showToast);

    // ========== 批量扫码导入弹窗拖拽与摄像头完善 ==========
    function bindQrDropZone() {
      const dropZone = document.getElementById('qrDropZone');
      if (!dropZone) return;
      dropZone.ondragover = e => { e.preventDefault(); dropZone.classList.add('bg-info', 'bg-opacity-10'); };
      dropZone.ondragleave = e => { e.preventDefault(); dropZone.classList.remove('bg-info', 'bg-opacity-10'); };
      dropZone.ondrop = e => {
        e.preventDefault();
        dropZone.classList.remove('bg-info', 'bg-opacity-10');
        if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {
          handleFiles(e.dataTransfer.files);
        }
      };
      dropZone.onclick = () => {
        const input = document.getElementById('qrImgInput');
        if (input) input.click();
      };
    }
    watch(showScanModal, v => { if (v) nextTick(bindQrDropZone); });

    onMounted(() => {
      nextTick(() => {
        if (window.innerWidth <= 600) {
          setTimeout(() => {

          }, 100);
        }
      });
    });
    watch(filteredTokens, () => {
      nextTick(() => {
        if (window.innerWidth <= 600) {
          setTimeout(() => {

          }, 100);
        }
      });
    });

    function onCardTouchStart(token) {
      if (isMultiSelectMode.value) return;
      longPressTimer = setTimeout(() => {
        isMultiSelectMode.value = true;
        if (!selectedIds.value.includes(token.id)) {
          selectedIds.value.push(token.id);
        }
      }, 500);
    }
    function onCardTouchEnd() {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }
    function onCardTouchCancel() {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }
    function exitMultiSelectMode() {
      isMultiSelectMode.value = false;
      selectedIds.value = [];
    }

    const swipeStates = reactive({});
    let touchStartX = 0;
    let touchStartY = 0;
    let touchMoved = false;
    function onCardSwipeStart(token, event) {
      if (!isMobile.value) return;
      touchMoved = false;
      touchStartX = 0;
      touchStartY = 0;
      swipeStates[token.id] = swipeStates[token.id] || { offset: 0, deleting: false };
      if (event.touches && event.touches.length === 1) {
        touchStartX = event.touches[0].clientX;
        touchStartY = event.touches[0].clientY;
      }
    }
    function onCardSwipeMove(token, event) {
      if (!isMobile.value) return;
      if (!event.touches || event.touches.length !== 1) return;
      const dx = event.touches[0].clientX - touchStartX;
      const dy = event.touches[0].clientY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 10) {
        touchMoved = true;
        swipeStates[token.id].offset = dx;
        event.preventDefault();
      }
    }
    function onCardSwipeEnd(token) {
      if (!isMobile.value) return;
      const offset = swipeStates[token.id].offset;
      if (touchMoved && offset < -140) {
        // 左滑直接删除
        deleteToken(token.id);
        swipeStates[token.id].offset = 0;
        swipeStates[token.id].deleting = false;
      } else if (touchMoved && offset > 140) {
        // 右滑进入编辑界面
        openEditModal(token);
        swipeStates[token.id].offset = 0;
        swipeStates[token.id].deleting = false;
      } else {
        swipeStates[token.id].offset = 0;
        swipeStates[token.id].deleting = false;
      }
      touchMoved = false;
    }
    function onCardSwipeCancel(token) {
      if (!isMobile.value) return;
      swipeStates[token.id].offset = 0;
      swipeStates[token.id].deleting = false;
      touchMoved = false;
    }

    // 本地加密导出
    function batchExportEncryptedJSON() {
      if (!selectedIds.value.length) { showToast('请先选择要导出的令牌', 'info'); return; }
      const arr = tokens.value.filter(t => selectedIds.value.includes(t.id));
      const data = JSON.stringify(arr, null, 2);
      getEncryptPassword('totp_manager_default').then(password => {
        if (!password) { showToast('已取消导出', 'info'); return; }
        const encrypted = encryptData(data, password);
        const blob = new Blob([encrypted], {type: 'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'totp_tokens_encrypted.txt';
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        showToast('已导出加密文件', 'success');
      });
    }

    // 统一导出/备份弹窗状态
    const showExportModal = ref(false);
    const exportType = ref('none'); // 'none' | 'custom'
    const exportPassword = ref('');
    const exportAction = ref(''); // 'gist-backup' | 'gist-restore' | 'gist' | 'local'

    function openExportModal(action) {
      exportType.value = 'none';
      exportPassword.value = '';
      exportAction.value = action; // 'gist-backup' | 'gist-restore' | 'gist' | 'local'
      showExportModal.value = true;
    }

    async function confirmExport() {
      let password = exportType.value === 'custom' ? exportPassword.value : null;
      if (exportType.value === 'custom' && !password) {
        showToast('请输入加密密码', 'danger');
        return;
      }
      if (exportType.value === 'custom' && password.trim() === '') {
        showToast('加密密码不能为空', 'danger');
        return;
      }
      if (exportAction.value === 'local') {
        // 本地导出
        const arr = tokens.value.filter(t => selectedIds.value.includes(t.id));
        let data = JSON.stringify(arr, null, 2);
        if (password) {
          data = encryptData(data, password);
        }
        const blob = new Blob([data], {type: 'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = password ? 'totp_tokens_encrypted.txt' : 'totp_tokens.json';
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        showToast(password ? '已导出加密文件' : '已导出明文文件', 'success');
        showExportModal.value = false;
      } else if (exportAction.value === 'gist') {
        // ...原 gist 备份逻辑（可删除或保留）...
      } else if (exportAction.value === 'gist-backup') {
        // Gist 加密备份
        try {
          const data = JSON.stringify(tokens.value, null, 2);
          let content = data;
          let filename = 'totp_tokens.json';
          if (password) {
            content = encryptData(data, password);
            filename = 'totp_tokens_encrypted.txt';
          }
          const res = await fetch('https://api.github.com/gists', {
            headers: { Authorization: 'token ' + gistPAT.value }
          });
          if (!res.ok) throw new Error('获取 Gist 列表失败');
          const gists = await res.json();
          let gist = gists.find(g => g.files && g.files[filename]);
          let gistId;
          if (gist) {
            gistId = gist.id;
          } else {
            const createRes = await fetch('https://api.github.com/gists', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', Authorization: 'token ' + gistPAT.value },
              body: JSON.stringify({
                description: password ? 'TOTP 令牌加密自动备份' : 'TOTP 令牌明文自动备份',
                public: false,
                files: { [filename]: { content } }
              })
            });
            if (!createRes.ok) throw new Error('创建 Gist 失败');
            const data = await createRes.json();
            gistId = data.id;
          }
          const patchRes = await fetch('https://api.github.com/gists/' + gistId, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json', Authorization: 'token ' + gistPAT.value },
            body: JSON.stringify({
              files: { [filename]: { content } }
            })
          });
          if (!patchRes.ok) throw new Error('Gist 更新失败');
          showToast(password ? 'Gist 加密备份成功！' : 'Gist 明文备份成功！', 'success');
          showExportModal.value = false;
          showGistModal.value = false;
        } catch (e) {
          showToast('Gist 备份失败：' + e.message, 'danger');
        }
      } else if (exportAction.value === 'gist-restore') {
        // Gist 加密恢复
        try {
          const res = await fetch('https://api.github.com/gists', {
            headers: { Authorization: 'token ' + gistPAT.value }
          });
          if (!res.ok) throw new Error('获取 Gist 列表失败');
          // 优先找加密文件
          let gist = null;
          let filename = '';
          if (password) {
            gist = (await res.json()).find(g => g.files && g.files['totp_tokens_encrypted.txt']);
            filename = 'totp_tokens_encrypted.txt';
          } else {
            gist = (await res.json()).find(g => g.files && g.files['totp_tokens.json']);
            filename = 'totp_tokens.json';
          }
          if (!gist) throw new Error('未找到对应 Gist 文件');
          const rawUrl = gist.files[filename].raw_url;
          const fileRes = await fetch(rawUrl);
          if (!fileRes.ok) throw new Error('下载 Gist 文件失败');
          let arr = null;
          if (password) {
            const encrypted = await fileRes.text();
            const decrypted = decryptData(encrypted, password);
            if (!decrypted) throw new Error('密码错误或文件损坏');
            arr = JSON.parse(decrypted);
          } else {
            arr = await fileRes.json();
          }
          if (!Array.isArray(arr)) throw new Error('Gist 文件内容格式错误');
          tokens.value = arr;
          showToast('Gist 恢复成功！', 'success');
          showExportModal.value = false;
          showGistModal.value = false;
        } catch (e) {
          showToast('Gist 恢复失败：' + e.message, 'danger');
        }
      }
    }

    return {
      tokens, selectedIds, allSelected, recentlyDeleted, toastList, search, remain, isMobile,
      filteredTokens, selectAll, clearSelect, deleteToken, copyCode, totp, progressPercent,
      showAddModal, showEditModal, addForm, editForm, editingToken,
      openAddModal, addToken, openEditModal, saveEdit, closeEditModal,
      showQRModal, qrToken, openQRModal,
      showScanModal, scanProgress, openScanModal, handleFiles,
      cameraActive, startCamera, stopCamera,
      showGistModal, gistPAT, gistError, openGistModal, saveGistPAT, backupToGist, restoreFromGist,
      batchDelete, batchExportJSON,
      batchExportEncryptedJSON,
      isMultiSelectMode,
      onCardTouchStart,
      onCardTouchEnd,
      onCardTouchCancel,
      exitMultiSelectMode,
      swipeStates,
      onCardSwipeStart,
      onCardSwipeMove,
      onCardSwipeEnd,
      onCardSwipeCancel,
      showExportModal,
      exportType,
      exportPassword,
      exportAction,
      openExportModal,
      confirmExport,
    };
  },
  template: `
    <div class="container py-3">
      <h2 class="mb-4"><i class="bi bi-shield-lock"></i> TOTP令牌管理器</h2>
      <div class="search-box-sticky">
        <input v-model="search" class="form-control flex-grow-1 me-1" :placeholder="(selectedIds.length ? '搜索...（已选' + selectedIds.length + '项）' : '搜索...')" style="min-width:0;">
        <input type="checkbox" class="form-check-input me-1" v-model="allSelected" :title="'全选'" v-if="!isMobile || isMultiSelectMode">
        <button class="btn btn-success btn-sm me-1" @click="openAddModal" title="新增"><i class="bi bi-plus"></i></button>
        <template v-if="!isMobile">
          <!-- PC端平铺 -->
          <button class="btn btn-outline-info btn-sm me-1" @click="openScanModal"><i class="bi bi-qr-code-scan"></i></button>
          <button class="btn btn-outline-dark btn-sm me-1" @click="showGistModal=true"><i class="bi bi-github"></i></button>
          <button class="btn btn-outline-danger btn-sm me-1" @click="batchDelete"><i class="bi bi-trash"></i></button>
          <button class="btn btn-outline-success btn-sm me-1" @click="openExportModal('local')"><i class="bi bi-download"></i></button>
        </template>
        <template v-else>
          <div class="dropdown">
            <button class="btn btn-outline-secondary btn-sm" type="button" data-bs-toggle="dropdown" title="更多">
              <i class="bi bi-three-dots"></i>
            </button>
            <ul class="dropdown-menu dropdown-menu-end">
              <li><a class="dropdown-item" href="#" @click.prevent="openScanModal"><i class="bi bi-qr-code-scan"></i> 批量扫码导入</a></li>
              <li><a class="dropdown-item" href="#" @click.prevent="showGistModal=true"><i class="bi bi-github"></i> Gist云备份</a></li>
              <li><a class="dropdown-item" href="#" @click.prevent="batchDelete"><i class="bi bi-trash"></i> 批量删除</a></li>
              <li><a class="dropdown-item" href="#" @click.prevent="openExportModal('local')"><i class="bi bi-download"></i> 批量导出JSON</a></li>
            </ul>
          </div>
          <button v-if="isMultiSelectMode" class="btn btn-outline-secondary btn-sm ms-2" @click="exitMultiSelectMode"><i class="bi bi-x-circle"></i> 取消多选</button>
        </template>
      </div>
      <div v-if="filteredTokens.length === 0" class="alert alert-warning">暂无令牌</div>
      <div v-else>
        <div v-for="token in filteredTokens" :key="token.id" class="card token-card" :id="'card-' + token.id" :data-id="token.id"
          @touchstart="onCardTouchStart(token); onCardSwipeStart(token, $event)"
          @touchmove="onCardSwipeMove(token, $event)"
          @touchend="onCardTouchEnd(); onCardSwipeEnd(token)"
          @touchcancel="onCardTouchCancel(); onCardSwipeCancel(token)"
          :style="isMobile && swipeStates[token.id] && swipeStates[token.id].offset ? ('transform: translateX(' + swipeStates[token.id].offset + 'px); transition: 0.2s;') : ''">
          <div class="card-body" v-if="isMobile">
            <div class="token-info-row" style="position:relative;">
              <input v-if="isMultiSelectMode" type="checkbox" class="form-check-input me-2 select-cbx" v-model="selectedIds" :value="token.id">
              <span>{{token.userInfo || '未命名'}}<span v-if="!token.secret" class="badge bg-danger ms-2">无密钥</span></span>
              <button
                v-if="swipeStates[token.id] && swipeStates[token.id].deleting"
                class="btn btn-danger btn-sm ms-2"
                @click="deleteToken(token.id)"
                style="position:absolute; right:10px; top:50%; transform:translateY(-50%); z-index:2;"
              >删除</button>
            </div>
            <div class="token-code-row mt-2">
              <span class="token-code" :data-copy="totp(token.secret, remain)" @click="copyCode(totp(token.secret, remain), $event)">{{totp(token.secret, remain)}}</span>
              <canvas class="totp-pie" :id="'pie-' + token.id" width="28" height="28"></canvas>
            </div>
            <div class="d-flex mt-2 gap-2" v-if="!isMobile">
              <button class="btn btn-outline-primary btn-sm flex-fill" @click="openEditModal(token)"><i class="bi bi-pencil"></i> 编辑</button>
              <button class="btn btn-outline-danger btn-sm flex-fill" @click="deleteToken(token.id)"><i class="bi bi-trash"></i> 删除</button>
              <button class="btn btn-outline-success btn-sm flex-fill" @click="openQRModal(token)"><i class="bi bi-qr-code"></i> 导出二维码</button>
            </div>
          </div>
          <div class="card-body d-flex align-items-center gap-3" v-else>
            <input type="checkbox" class="form-check-input me-2 select-cbx" v-model="selectedIds" :value="token.id">
            <div class="token-info flex-grow-1" :title="token.userInfo">{{token.userInfo || '未命名'}}<span v-if="!token.secret" class="badge bg-danger ms-2">无密钥</span></div>
            <span class="token-code" :data-copy="totp(token.secret, remain)" @click="copyCode(totp(token.secret, remain), $event)">{{totp(token.secret, remain)}}</span>
            <div class="progress flex-grow-1 me-1" style="max-width:80px;">
              <div class="progress-bar" :style="{width: progressPercent + '%'}"></div>
            </div>
            <span class="token-timer" style="min-width:36px;">{{remain}} 秒</span>
            <div class="token-actions ms-2 flex-shrink-0 d-flex gap-1">
              <button class="btn btn-outline-primary btn-sm" @click="openEditModal(token)"><i class="bi bi-pencil"></i> 编辑</button>
              <button class="btn btn-outline-danger btn-sm" @click="deleteToken(token.id)"><i class="bi bi-trash"></i> 删除</button>
              <button class="btn btn-outline-success btn-sm" @click="openQRModal(token)"><i class="bi bi-qr-code"></i> 导出二维码</button>
            </div>
          </div>
        </div>
      </div>
      <!-- 新增弹窗 -->
      <div class="modal fade" tabindex="-1" :class="{show:showAddModal}" style="display: block;" v-if="showAddModal">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">添加 TOTP 令牌</h5>
              <button type="button" class="btn-close" @click="showAddModal=false"></button>
            </div>
            <div class="modal-body">
              <div class="mb-3">
                <label class="form-label">用户信息</label>
                <input type="text" class="form-control" v-model="addForm.userInfo" placeholder="如：邮箱/账号/描述">
              </div>
              <div class="mb-3">
                <label class="form-label">密钥（Base32）</label>
                <input type="text" class="form-control" v-model="addForm.secret" placeholder="如：JBSWY3DPEHPK3PXP">
                <div class="form-text">请确保密钥为 Base32 格式</div>
              </div>
              <div class="error-message">{{addForm.error}}</div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" @click="showAddModal=false">取消</button>
              <button type="button" class="btn btn-primary" @click="addToken">添加</button>
            </div>
          </div>
        </div>
      </div>
      <!-- 编辑弹窗 -->
      <div class="modal fade" tabindex="-1" :class="{show:showEditModal}" style="display: block;" v-if="showEditModal">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">编辑 TOTP 令牌</h5>
              <button type="button" class="btn-close" @click="closeEditModal"></button>
            </div>
            <form @submit.prevent="saveEdit">
            <div class="modal-body">
              <div class="mb-3">
                <label class="form-label">用户信息</label>
                <input type="text" class="form-control" v-model="editForm.userInfo">
              </div>
              <div class="mb-3">
                <label class="form-label">密钥（Base32）</label>
                <input type="text" class="form-control" v-model="editForm.secret">
                <div class="form-text">请确保密钥为 Base32 格式</div>
              </div>
              <div class="error-message text-danger">{{editForm.error}}</div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" @click="closeEditModal">取消</button>
              <button type="submit" class="btn btn-primary">保存</button>
            </div>
            </form>
          </div>
        </div>
      </div>
      <!-- 二维码导出弹窗 -->
      <div class="modal fade" tabindex="-1" :class="{show:showQRModal}" style="display: block;" v-if="showQRModal">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">导出二维码</h5>
              <button type="button" class="btn-close" @click="showQRModal=false"></button>
            </div>
            <div class="modal-body text-center">
              <div id="qrcode"></div>
              <div class="mt-3" style="font-size:1.1rem;font-weight:500;color:#333;word-break:break-all;">{{qrToken?.userInfo || '未命名'}}</div>
              <div class="mt-2">可用 Google Authenticator 等扫码导入</div>
            </div>
          </div>
        </div>
      </div>
      <!-- 批量扫码导入弹窗（图片） -->
      <div class="modal fade" tabindex="-1" :class="{show:showScanModal}" style="display: block;" v-if="showScanModal">
        <div class="modal-dialog modal-lg">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">批量扫码导入 TOTP</h5>
              <button type="button" class="btn-close" @click="showScanModal=false"></button>
            </div>
            <div class="modal-body">
              <div id="qrDropZone" class="mb-3 p-4 border border-2 border-dashed rounded text-center" style="background:#f8f9fa;cursor:pointer;transition:background 0.2s;">
                <div class="text-muted"><i class="bi bi-cloud-upload" style="font-size:2rem;"></i></div>
                <div class="mt-2">拖拽图片文件到此处，或点击下方按钮选择</div>
              </div>
              <input type="file" accept=".png,.jpg,.jpeg,.bmp,.gif,.webp,.json,.csv,.txt,image/*" id="qrImgInput" class="form-control mb-2" multiple @change="e=>handleFiles(e.target.files)" style="display:none">
              <div class="form-text mb-2">可选择/拖拽多种文件，支持二维码图片（PNG、JPG）、JSON、CSV、TXT（otpauth://URI）等格式</div>
              <div class="text-center mb-3">
                <video id="qrVideo" :style="{display: cameraActive ? '' : 'none', width: '100%', maxWidth: '300px'}" autoplay playsinline></video>
                <div class="mt-2">
                  <button class="btn btn-outline-secondary btn-sm me-2" v-if="!cameraActive" @click="startCamera"><i class="bi bi-camera-video"></i> 摄像头扫码</button>
                  <button class="btn btn-outline-secondary btn-sm" v-if="cameraActive" @click="stopCamera"><i class="bi bi-x-circle"></i> 停止扫码</button>
                </div>
                <div v-if="cameraActive" class="mt-2 text-muted small">
                  <i class="bi bi-search"></i> 正在扫描二维码...
                </div>
              </div>
              <div class="progress mb-2" v-if="scanProgress.total">
                <div class="progress-bar" role="progressbar" :style="{width: (scanProgress.success+scanProgress.fail)*100/scanProgress.total+'%'}"></div>
              </div>
              <div v-if="scanProgress.total" class="mb-2">
                总文件数: {{scanProgress.total}}，成功: {{scanProgress.success}}，失败: {{scanProgress.fail}}
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- Gist配置弹窗 -->
      <div class="modal fade" tabindex="-1" :class="{show:showGistModal}" style="display: block;" v-if="showGistModal">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">GitHub Gist 云操作</h5>
              <button type="button" class="btn-close" @click="showGistModal=false"></button>
            </div>
            <div class="modal-body">
              <div class="mb-2">
                <label class="form-label">GitHub PAT（gist权限）</label>
                <input type="text" class="form-control" v-model="gistPAT" placeholder="ghp_xxx">
                <div class="form-text">仅保存在本地浏览器，不上传服务器</div>
                <div class="error-message">{{gistError}}</div>
              </div>
              <div class="alert alert-info mt-2" style="font-size:0.98rem;">
                <i class="bi bi-shield-lock"></i> 支持加密备份和加密恢复，推荐自定义密码加密，遗失密码将无法恢复数据。
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" @click="showGistModal=false">取消</button>
              <button type="button" class="btn btn-primary" @click="saveGistPAT">保存PAT</button>
              <button type="button" class="btn btn-success" @click="openExportModal('gist-backup')">
                <i class="bi bi-cloud-upload"></i> 加密备份
              </button>
              <button type="button" class="btn btn-info" @click="openExportModal('gist-restore')">
                <i class="bi bi-cloud-download"></i> 加密恢复
              </button>
            </div>
          </div>
        </div>
      </div>
      <!-- 统一导出/备份弹窗 -->
      <div class="modal fade" tabindex="-1" :class="{show:showExportModal}" style="display: block;" v-if="showExportModal">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">
                <template v-if="exportAction==='gist-backup'">Gist加密备份选项</template>
                <template v-else-if="exportAction==='gist-restore'">Gist加密恢复选项</template>
                <template v-else>本地导出选项</template>
              </h5>
              <button type="button" class="btn-close" @click="showExportModal=false"></button>
            </div>
            <div class="modal-body">
              <div class="form-check mb-2">
                <input class="form-check-input" type="radio" id="exportNone" value="none" v-model="exportType">
                <label class="form-check-label" for="exportNone">不加密（明文）</label>
              </div>
              <div class="form-check mb-2">
                <input class="form-check-input" type="radio" id="exportCustom" value="custom" v-model="exportType">
                <label class="form-check-label" for="exportCustom">自定义密码加密</label>
              </div>
              <div v-if="exportType==='custom'" class="mb-2">
                <input type="password" class="form-control" v-model="exportPassword" placeholder="请输入加密密码">
              </div>
              <div class="form-text">
                <template v-if="exportAction==='gist-backup'">
                  请选择是否加密备份到Gist，推荐自定义密码加密，遗失密码将无法恢复数据！
                </template>
                <template v-else-if="exportAction==='gist-restore'">
                  请选择是否用密码解密恢复Gist备份，若为明文备份可直接恢复。
                </template>
                <template v-else>
                  如选择加密，请牢记密码，遗失将无法恢复数据！
                </template>
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" @click="showExportModal=false">取消</button>
              <button type="button" class="btn btn-primary" @click="confirmExport">确定</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  `
}).mount('#app');

// 动态加载jsQR
function loadJsQR() {
  return new Promise((resolve, reject) => {
    if (window.jsQR) return resolve(window.jsQR);
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js';
    script.onload = () => resolve(window.jsQR);
    script.onerror = reject;
    document.body.appendChild(script);
  });
}
// 动态加载kjua
function loadKjua() {
  return new Promise((resolve, reject) => {
    if (window.kjua) return resolve(window.kjua);
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/kjua@0.1.1/dist/kjua.min.js';
    script.onload = () => resolve(window.kjua);
    script.onerror = reject;
    document.body.appendChild(script);
  });
}

// 在用到jsQR和kjua的地方分别await loadJsQR()和await loadKjua()
// 例如：
// await loadJsQR();
// const code = jsQR(...);
// await loadKjua();
// const qr = kjua(...);

// Bootstrap Icons建议用SVG inline方式替换

// 1. 通用加密/解密函数
function encryptData(data, password) {
  return CryptoJS.AES.encrypt(data, password).toString();
}
function decryptData(text, password) {
  return CryptoJS.AES.decrypt(text, password).toString(CryptoJS.enc.Utf8);
}
// 2. 通用文件读取函数
function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.onerror = reject;
    reader.readAsText(file);
  });
}
// 3. Toast复用（showToast, showUndoToast已较好，可保持）
// 4. 在导出/导入/备份/恢复等相关地方用encryptData/decryptData/readFileAsText替换原有CryptoJS和FileReader调用

</script>
</body>
</html>
